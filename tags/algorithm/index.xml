<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithm on Danzou1ge6</title><link>/tags/algorithm/</link><description>Recent content in algorithm on Danzou1ge6</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 01 Mar 2023 16:04:18 +0800</lastBuildDate><atom:link href="/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Extended Joseph Ring</title><link>/posts/josephring/</link><pubDate>Wed, 01 Mar 2023 16:04:18 +0800</pubDate><guid>/posts/josephring/</guid><description>Extended Joseph Ring The Extension In traditional Joseph Ring, candidates numbered $1, \cdots, n$ are eliminated $m$ by $m$.
An extension to this is choosing different $m$ at each elimination. For example, with $n = 5$ and $k = [1, 2, 3, 4]$, the process is illustrated below:
Original 1 2 3 4 5 k = 1 x 1 2 3 4 k = 2 3 x 1 2 k = 3 x 1 2 k = 4 1 x Eventually, only $4$ is left.</description><content>&lt;h1 id="extended-joseph-ring">Extended Joseph Ring&lt;/h1>
&lt;h2 id="the-extension">The Extension&lt;/h2>
&lt;p>In traditional Joseph Ring, candidates numbered $1, \cdots, n$ are eliminated $m$ by $m$.&lt;/p>
&lt;p>An extension to this is choosing different $m$ at each elimination. For example, with $n = 5$ and $k = [1, 2, 3, 4]$, the process is illustrated below:&lt;/p>
&lt;pre tabindex="0">&lt;code>Original 1 2 3 4 5
k = 1 x 1 2 3 4
k = 2 3 x 1 2
k = 3 x 1 2
k = 4 1 x
&lt;/code>&lt;/pre>&lt;p>Eventually, only $4$ is left.&lt;/p>
&lt;h2 id="problem">Problem&lt;/h2>
&lt;p>Usually, the problem is to determine which canditate will remain after $n - 1$ rounds of elimination.&lt;/p>
&lt;p>A simple way is to utilize circular linked list. However, there exists a faster method, which can be extended as well. This method is based on the following result.&lt;/p>
&lt;h2 id="a-useful-result">A Useful Result&lt;/h2>
&lt;p>We define that before an elimination, remaining candidates are numbered
$$1, \cdots n$$&lt;/p>
&lt;p>Then, the $k^{\mathrm{th}}$ candidate is eliminated, leaving
$$X = [1, \cdots, k - 1, k + 1, \cdots, n]$$
which are re-indexed as
$$Y = [n - k + 1, \cdots, n - 1, 1, \cdots, n - k]$$&lt;/p>
&lt;p>Actually, it can be verified that there exists a mapping from $X_i$ to $Y_i$:
$$Y_i = p(X_i) = (X_i + n - k) ;\mathrm{mod}; n$$&lt;/p>
&lt;p>from which we can derive the inverse mapping
$$X_i = p^{-1}(Y_i) = (Y_i + k) ;\mathrm{mod}; n$$&lt;/p>
&lt;p>Note that for the $\mathrm{mod}$ operation here,
$$0 ;\mathrm{mod}; n = n$$
to make sure $p^{-1}(Y_i)$ is within range of $X_i$.&lt;/p>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;p>The problem can be restated as: Given a set of candidates indexed $1, \cdots, n$, and a series of $k_1, \cdots, k_{n-1}$, we need to determine the index for the eventually remaining candidate.&lt;/p>
&lt;p>For each $k_t$, we define $p_t$ according to the above result. Note that the number of remaining candidates $n$ in $p$&amp;rsquo;s defination needs to be substituted by $n - t + 1$. Then, we annotate the origin indices with
$$X^0 = [1, \cdots, n]$$&lt;/p>
&lt;p>After eliminating $k_1$ from $X_0$, the remainings are re-indexed
$$X^1_i = p(X^0_i), X^0_i \ne k_1$$
for next round of elimination.&lt;/p>
&lt;p>The process is repeated for $n - 1$ times, and the final $X^{n - 1}$ only consists of single candidate indexed $1$. The goal is to find out the original index for this candidate.&lt;/p>
&lt;p>This can be achieved by traversing back the elimination process. Using the previous result, if an item is indexed $x$ in the $t^{\mathrm{th}}$ round, its index in the ${t-1}^{\mathrm{th}}$ round must be $p_t^{-1}(x)$. Therfore, the origin index of the final candidate is
$$p_1^{-1} \circ p_2^{-1} \circ \cdots \circ p_{n - 1}^{-1} (1)$$&lt;/p>
&lt;p>The Rust code for solving the probel is listed below.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Rust" data-lang="Rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">last&lt;/span>(n: &lt;span style="color:#66d9ef">i32&lt;/span>, k_vec: Vec&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">i32&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>) -&amp;gt; Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">i32&lt;/span>, ()&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> k_vec.len() &lt;span style="color:#f92672">!=&lt;/span> (n &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>).try_into().unwrap() { Err(()) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> t &lt;span style="color:#66d9ef">in&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">..&lt;/span>n).rev() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">=&lt;/span> (x &lt;span style="color:#f92672">+&lt;/span> k_vec[&lt;span style="color:#66d9ef">usize&lt;/span>::try_from(t).unwrap() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>]) &lt;span style="color:#f92672">%&lt;/span> (n &lt;span style="color:#f92672">-&lt;/span> t &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ok(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Rust" data-lang="Rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> k_vec &lt;span style="color:#f92672">=&lt;/span> vec![&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> last(n, k_vec).unwrap();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println!(&lt;span style="color:#e6db74">&amp;#34;The remaining candidate is {}&amp;#34;&lt;/span>, x);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>The remaining candidate is 4
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Rust" data-lang="Rust">&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>KMP String Matching Algorithm</title><link>/posts/kmp/</link><pubDate>Wed, 01 Mar 2023 16:04:18 +0800</pubDate><guid>/posts/kmp/</guid><description>KMP String Matching Algorithm Rational Brute-force string matching requires $O(MN)$ time, where $N$ is the length of the source string $S$, and $M$ is the length of the target string $P$.
However, utilizing the following fact, time consumption can be further reduced:
For example,
Index: 012345 S = abxabx P = abxaby &amp;lt;- Attempt 1 abx &amp;lt;- Attempt 2 When Attempt 1 failed because $S[5] \ne P[5]$, $S[:4]$ has already been matched.</description><content>&lt;h1 id="kmp-string-matching-algorithm">KMP String Matching Algorithm&lt;/h1>
&lt;h2 id="rational">Rational&lt;/h2>
&lt;p>Brute-force string matching requires $O(MN)$ time, where $N$ is the length of the &lt;strong>source string&lt;/strong> $S$, and $M$ is the length of the &lt;strong>target string&lt;/strong> $P$.&lt;/p>
&lt;p>However, utilizing the following fact, time consumption can be further reduced:&lt;/p>
&lt;p>For example,&lt;/p>
&lt;pre tabindex="0">&lt;code>Index: 012345
S = abxabx
P = abxaby &amp;lt;- Attempt 1
abx &amp;lt;- Attempt 2
&lt;/code>&lt;/pre>&lt;p>When Attempt 1 failed because $S[5] \ne P[5]$, $S[:4]$ has already been matched. Noticing that $P$ starts with &amp;ldquo;ab&amp;rdquo; while $S[3:5]$, which equals $P[3:5]$, is also &amp;ldquo;ab&amp;rdquo;, we can continue matching by aligning &amp;ldquo;x&amp;rdquo; at $P[2]$ with $S[5]$ as shown in Attempt 2.&lt;/p>
&lt;h2 id="the-next-array">The &amp;ldquo;next&amp;rdquo; Array&lt;/h2>
&lt;p>Therefore, the key to accelerating matching is by locating &lt;strong>longest identical prefix and suffix&lt;/strong>(LIPS) in $P[:j]$ for every $j$. We determine these prefixes and suffices with an &amp;ldquo;next&amp;rdquo; array $W$, defined as&lt;/p>
&lt;p>$$
W[i] = \max \left \{k | P[:k] = P[i-k:i] \right \}
$$&lt;/p>
&lt;p>For example,&lt;/p>
&lt;pre tabindex="0">&lt;code>Index: 012345
P = abxaby
W = 010012
&lt;/code>&lt;/pre>&lt;p>To calculate $W$ from $P$, we use &lt;strong>recursion&lt;/strong>.&lt;/p>
&lt;p>Firstly, $W[0]$ is certainly $0$.&lt;/p>
&lt;p>Then, assuming that we have already obtained $W[i] = k$, and there exists $P[k] = P[i]$, we can simply set $W[i + 1]$ to $k + 1$.&lt;/p>
&lt;p>However, when $P[k] \ne P[i]$, we will have to look for a shorter LIPS.&lt;/p>
&lt;pre tabindex="0">&lt;code>Index: 0123456789ABCD
P = abyabxabyabyz
---- ----|
----- -----| &amp;lt;- i = B, W[B] = W[A] + 1
--- ---| &amp;lt;- i + 1 = C
&lt;/code>&lt;/pre>&lt;p>For example, when $i = B$, there exists LIPS &amp;ldquo;abyab&amp;rdquo;, however when $i = C$, there only exists shorter &amp;ldquo;aby&amp;rdquo;. Noticing that the shorter prefix, which is &amp;ldquo;aby&amp;rdquo;, can be splitted into two part &amp;ldquo;ab&amp;rdquo; and &amp;ldquo;y&amp;rdquo;. &amp;ldquo;ab&amp;rdquo; is actually the LIPS of &amp;ldquo;abyab&amp;rdquo;, which is again the LIPS of $P[:B]$!&lt;/p>
&lt;p>Therefore, all we have to do when $P[k] \ne P[i]$ is:&lt;/p>
&lt;ul>
&lt;li>Find the LIPS of $P[:k]$, length of which has been calculated and stored in $W[k] = l$.&lt;/li>
&lt;li>See if $P[l] = P[i]$. If so, $W[i + 1]$ would be $l + 1$. Otherwise, $W[i + 1]$ would be 0.&lt;/li>
&lt;/ul>
&lt;p>The Rust code for solving $W$ is listed below. (To simplify stuff, char codes stored in &lt;code>Vec&amp;lt;char&amp;gt;&lt;/code> is used instead of UTF-8 encoded &lt;code>String&lt;/code>)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Rust" data-lang="Rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">/// Wrapper for [`Vec&amp;lt;char&amp;gt;`]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Chars&lt;/span>(Vec&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> From&lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> Chars {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span>(s: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Self&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Self(s.chars().collect())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> From&lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>Chars&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span>(s: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Chars&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Self&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> st &lt;span style="color:#f92672">=&lt;/span> String::new();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>c &lt;span style="color:#66d9ef">in&lt;/span> s.&lt;span style="color:#ae81ff">0.&lt;/span>iter() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> st.push(c);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> st
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Pattern&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> P: &lt;span style="color:#a6e22e">Chars&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> W: Vec&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">usize&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Pattern {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span>(P: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Self&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> P &lt;span style="color:#f92672">=&lt;/span> Chars::from(P);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> W &lt;span style="color:#f92672">=&lt;/span> Vec::with_capacity(P.&lt;span style="color:#ae81ff">0.&lt;/span>len());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> W.resize(P.&lt;span style="color:#ae81ff">0.&lt;/span>len(), &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">..&lt;/span>P.&lt;span style="color:#ae81ff">0.&lt;/span>len() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> W[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> W[i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> P.&lt;span style="color:#ae81ff">0&lt;/span>[i] &lt;span style="color:#f92672">==&lt;/span> P.&lt;span style="color:#ae81ff">0&lt;/span>[k] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> l &lt;span style="color:#f92672">=&lt;/span> W[k];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> P.&lt;span style="color:#ae81ff">0&lt;/span>[l] &lt;span style="color:#f92672">==&lt;/span> P.&lt;span style="color:#ae81ff">0&lt;/span>[i] { l &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> { &lt;span style="color:#ae81ff">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Self { P, W }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Rust" data-lang="Rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> pat &lt;span style="color:#f92672">=&lt;/span> Pattern::from(&lt;span style="color:#e6db74">&amp;#34;abyabxabyabyz&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println!(&lt;span style="color:#e6db74">&amp;#34;P = {}&amp;#34;&lt;/span>, String::from(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pat.P));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println!(&lt;span style="color:#e6db74">&amp;#34;W = {:?}&amp;#34;&lt;/span>, pat.W);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>P = abyabxabyabyz
W = [0, 0, 0, 0, 1, 2, 0, 1, 2, 3, 4, 5, 3]
&lt;/code>&lt;/pre>
&lt;h2 id="matching">Matching&lt;/h2>
&lt;p>Now we have the &amp;ldquo;next&amp;rdquo; array $W$, we can do the matching.&lt;/p>
&lt;p>For example,&lt;/p>
&lt;pre tabindex="0">&lt;code>Index: 0123456
S = abyac &amp;lt;- j is used to index the char to be compared in S
- &amp;lt;- Mismatch found when i = j = 4
P = abyab &amp;lt;- i is used to index the char ... in P
W = 00001
abyab &amp;lt;- i set to W[i] = 1, and compare again
&lt;/code>&lt;/pre>&lt;p>Now mismatch occurred when $i = j = 4$, and all we have to do is to align $P$ again.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Rust" data-lang="Rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Pattern {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">match_str&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self, s: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>) -&amp;gt; Option&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">usize&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> chars &lt;span style="color:#f92672">=&lt;/span> s.chars();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> c &lt;span style="color:#f92672">=&lt;/span> chars.next();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">loop&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> self.P.&lt;span style="color:#ae81ff">0.&lt;/span>len() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Some(j &lt;span style="color:#f92672">-&lt;/span> self.P.&lt;span style="color:#ae81ff">0.&lt;/span>len());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> c {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> None &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> None,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Some(chr) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> self.P.&lt;span style="color:#ae81ff">0&lt;/span>[i] &lt;span style="color:#f92672">==&lt;/span> chr {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c &lt;span style="color:#f92672">=&lt;/span> chars.next();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> i &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c &lt;span style="color:#f92672">=&lt;/span> chars.next();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#75715e">// if P[0] mismatched, try j + 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> { i &lt;span style="color:#f92672">=&lt;/span> self.W[i]; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Rust" data-lang="Rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> idx &lt;span style="color:#f92672">=&lt;/span> pat.match_str(&lt;span style="color:#e6db74">&amp;#34;ababyyabyabxaabyabxabyabyzab&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// -------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println!(&lt;span style="color:#e6db74">&amp;#34;Match found at {}&amp;#34;&lt;/span>, idx.unwrap());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>Match found at 13
&lt;/code>&lt;/pre></content></item></channel></rss>