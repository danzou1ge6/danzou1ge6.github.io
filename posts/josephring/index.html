<!doctype html><html lang=en><head><title>Extended Joseph Ring :: Danzou1ge6</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Notes for Extended Joseph Ring"><meta name=keywords content="Joseph Ring"><meta name=robots content="noodp"><link rel=canonical href=/posts/josephring/><link rel=stylesheet href=/styles.css><link rel="shortcut icon" href=/img/theme-colors/blue.png><link rel=apple-touch-icon href=/img/theme-colors/blue.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Extended Joseph Ring"><meta property="og:description" content="Notes for Extended Joseph Ring"><meta property="og:url" content="/posts/josephring/"><meta property="og:site_name" content="Danzou1ge6"><meta property="og:image" content="/img/favicon/blue.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2023-03-01 16:04:18 +0800 +0800"></head><body class=blue><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Danzou1ge6</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li><li><a href=/links>Links</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li><li><a href=/links>Links</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=/posts/josephring/>Extended Joseph Ring</a></h1><div class=post-meta><time class=post-date>2023-03-01 ::</time></div><span class=post-tags>#<a href=/tags/algorithm/>algorithm</a>&nbsp;</span><div class=post-content><div><h1 id=extended-joseph-ring>Extended Joseph Ring<a href=#extended-joseph-ring class=hanchor arialabel=Anchor>&#8983;</a></h1><h2 id=the-extension>The Extension<a href=#the-extension class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In traditional Joseph Ring, candidates numbered $1, \cdots, n$ are eliminated $m$ by $m$.</p><p>An extension to this is choosing different $m$ at each elimination. For example, with $n = 5$ and $k = [1, 2, 3, 4]$, the process is illustrated below:</p><pre tabindex=0><code>Original  1 2 3 4 5
k = 1     x 1 2 3 4
k = 2       3 x 1 2
k = 3       x   1 2
k = 4           1 x
</code></pre><p>Eventually, only $4$ is left.</p><h2 id=problem>Problem<a href=#problem class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Usually, the problem is to determine which canditate will remain after $n - 1$ rounds of elimination.</p><p>A simple way is to utilize circular linked list. However, there exists a faster method, which can be extended as well. This method is based on the following result.</p><h2 id=a-useful-result>A Useful Result<a href=#a-useful-result class=hanchor arialabel=Anchor>&#8983;</a></h2><p>We define that before an elimination, remaining candidates are numbered
$$1, \cdots n$$</p><p>Then, the $k^{\mathrm{th}}$ candidate is eliminated, leaving
$$X = [1, \cdots, k - 1, k + 1, \cdots, n]$$
which are re-indexed as
$$Y = [n - k + 1, \cdots, n - 1, 1, \cdots, n - k]$$</p><p>Actually, it can be verified that there exists a mapping from $X_i$ to $Y_i$:
$$Y_i = p(X_i) = (X_i + n - k) ;\mathrm{mod}; n$$</p><p>from which we can derive the inverse mapping
$$X_i = p^{-1}(Y_i) = (Y_i + k) ;\mathrm{mod}; n$$</p><p>Note that for the $\mathrm{mod}$ operation here,
$$0 ;\mathrm{mod}; n = n$$
to make sure $p^{-1}(Y_i)$ is within range of $X_i$.</p><h2 id=solution>Solution<a href=#solution class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The problem can be restated as: Given a set of candidates indexed $1, \cdots, n$, and a series of $k_1, \cdots, k_{n-1}$, we need to determine the index for the eventually remaining candidate.</p><p>For each $k_t$, we define $p_t$ according to the above result. Note that the number of remaining candidates $n$ in $p$&rsquo;s defination needs to be substituted by $n - t + 1$. Then, we annotate the origin indices with
$$X^0 = [1, \cdots, n]$$</p><p>After eliminating $k_1$ from $X_0$, the remainings are re-indexed
$$X^1_i = p(X^0_i), X^0_i \ne k_1$$
for next round of elimination.</p><p>The process is repeated for $n - 1$ times, and the final $X^{n - 1}$ only consists of single candidate indexed $1$. The goal is to find out the original index for this candidate.</p><p>This can be achieved by traversing back the elimination process. Using the previous result, if an item is indexed $x$ in the $t^{\mathrm{th}}$ round, its index in the ${t-1}^{\mathrm{th}}$ round must be $p_t^{-1}(x)$. Therfore, the origin index of the final candidate is
$$p_1^{-1} \circ p_2^{-1} \circ \cdots \circ p_{n - 1}^{-1} (1)$$</p><p>The Rust code for solving the probel is listed below.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>last</span>(n: <span style=color:#66d9ef>i32</span>, k_vec: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>) -&gt; Result<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span>, ()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> k_vec.len() <span style=color:#f92672>!=</span> (n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>).try_into().unwrap() { Err(()) }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> t <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>n).rev() {
</span></span><span style=display:flex><span>            x <span style=color:#f92672>=</span> (x <span style=color:#f92672>+</span> k_vec[<span style=color:#66d9ef>usize</span>::try_from(t).unwrap() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]) <span style=color:#f92672>%</span> (n <span style=color:#f92672>-</span> t <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        Ok(x)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=display:flex><span><span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> k_vec <span style=color:#f92672>=</span> vec![<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> last(n, k_vec).unwrap();
</span></span><span style=display:flex><span>println!(<span style=color:#e6db74>&#34;The remaining candidate is </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x);
</span></span></code></pre></div><pre><code>The remaining candidate is 4
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust></code></pre></div></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/infix_expression/><span class=button__icon>←</span>
<span class=button__text>Infix Expression</span></a></span>
<span class="button next"><a href=/posts/kmp/><span class=button__text>KMP String Matching Algorithm</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div><link href=https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.4/katex.min.css rel=stylesheet><script src=https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.4/katex.min.js></script>
<script src=https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]}),console.log("Katex rendered.")})</script></body></html>