<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Danzou1ge6</title><link>/posts/</link><description>Recent content in Posts on Danzou1ge6</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 06 Feb 2023 18:21:30 +0800</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Audlyrics</title><link>/posts/audlyrics/</link><pubDate>Mon, 06 Feb 2023 18:21:30 +0800</pubDate><guid>/posts/audlyrics/</guid><description>动机 偶然发现一直在用的音乐播放器 Audacious 附带了一个命令行工具 audtool ，可以控制播放和获取播放信息。
这东西好啊，一直以来在 Plasmashell 上显示歌词的执念终于可以满足了。
技术路线 说起 Plasmashell 当然得是 Plamoid ，写 Plasmoid 当然得用 QML 。 但是吧， QML 框架好像不能直接访问文件系统，也不能执行命令，而要做到这些就得用 C++ ，这就很头疼了。
所以思索之下，我最终选择了用 Rust 写一个服务器，然后 QML 只负责展示。
Rust 的服务器框架随便选了个 Hyper 。
实现 思路很简单，在服务端开子进程执行 audtool ，获取当前曲目位置和播放时间，刚好我的歌词就存在曲目边上，和音频文件同名。
从歌词文件里读出来 LRC 格式的文本，然后解析后存起来，前端轮询的时候根据播放时间返回当前句子就行了。
QML 懒得学，但是刚好看见过一个叫 ypm-lyrics 的 Plasmoid ，这个是用来显示网易云第三方客户端 YesplayMusic 的歌词的，就直接拿来用了。
在和 Rust 的异步生命周期检查搏斗许久之后，终于搞定了服务端。
从中总结出来的经验是：闭包写短点，要不然容易晕。。。（汗
然后为了无感启动和关闭服务端，又为了不想让服务端一直开着（虽然基本不会占资源），在启动服务端时会把 Audacious 作为子进程启动，然后守护 Audacious 退出。
rust 服务器核心代码 let mut child = Command::new(&amp;#34;audacious&amp;#34;).spawn() .expect(&amp;#34;Cannot start audacious. Is it Installed?&amp;#34;); let state = Arc::new(Mutex::new(State::new())); let make_service = make_service_fn(move |_: &amp;amp;AddrStream| { let state = state.</description><content>&lt;h2 id="动机">动机&lt;/h2>
&lt;p>偶然发现一直在用的音乐播放器 Audacious 附带了一个命令行工具 &lt;code>audtool&lt;/code> ，可以控制播放和获取播放信息。&lt;/p>
&lt;p>这东西好啊，一直以来在 Plasmashell 上显示歌词的执念终于可以满足了。&lt;/p>
&lt;h2 id="技术路线">技术路线&lt;/h2>
&lt;p>说起 Plasmashell 当然得是 Plamoid ，写 Plasmoid 当然得用 QML 。
但是吧， QML 框架好像不能直接访问文件系统，也不能执行命令，而要做到这些就得用 C++ ，这就很头疼了。&lt;/p>
&lt;p>所以思索之下，我最终选择了用 Rust 写一个服务器，然后 QML 只负责展示。&lt;/p>
&lt;p>Rust 的服务器框架随便选了个 Hyper 。&lt;/p>
&lt;h2 id="实现">实现&lt;/h2>
&lt;p>思路很简单，在服务端开子进程执行 &lt;code>audtool&lt;/code> ，获取当前曲目位置和播放时间，刚好我的歌词就存在曲目边上，和音频文件同名。&lt;/p>
&lt;p>从歌词文件里读出来 LRC 格式的文本，然后解析后存起来，前端轮询的时候根据播放时间返回当前句子就行了。&lt;/p>
&lt;p>QML 懒得学，但是刚好看见过一个叫 &lt;code>ypm-lyrics&lt;/code> 的 Plasmoid ，这个是用来显示网易云第三方客户端 YesplayMusic 的歌词的，就直接拿来用了。&lt;/p>
&lt;p>在和 Rust 的异步生命周期检查搏斗许久之后，终于搞定了服务端。&lt;/p>
&lt;p>从中总结出来的经验是：闭包写短点，要不然容易晕。。。（汗&lt;/p>
&lt;p>然后为了无感启动和关闭服务端，又为了不想让服务端一直开着（虽然基本不会占资源），在启动服务端时会把 Audacious 作为子进程启动，然后守护 Audacious 退出。&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="1" type="checkbox" />
&lt;label for="1">
&lt;span class="collapsable-code__language">rust&lt;/span>
&lt;span class="collapsable-code__title">服务器核心代码&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-rust" >&lt;code>
let mut child = Command::new(&amp;#34;audacious&amp;#34;).spawn()
.expect(&amp;#34;Cannot start audacious. Is it Installed?&amp;#34;);
let state = Arc::new(Mutex::new(State::new()));
let make_service = make_service_fn(move |_: &amp;amp;AddrStream| {
let state = state.clone();
let service = service_fn(
move |req: Request&amp;lt;Body&amp;gt;| {
handle(state.clone(), req)
});
async move {
Ok::&amp;lt;_, Infallible&amp;gt;(service)
}
});
let addr = ([127, 0, 0, 1], 30123).into();
let server = Server::bind(&amp;amp;addr).serve(make_service);
let grace = server.with_graceful_shutdown(async move {
match child.wait().await {
Ok(code) =&amp;gt; println!(&amp;#34;Audacious returned with {}&amp;#34;, code),
Err(e) =&amp;gt; println!(&amp;#34;Audacious returned with IoError {:?}&amp;#34;, e)
};
});
if let Err(e) = grace.await {
eprintln!(&amp;#34;Server error: {}&amp;#34;, e);
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>端口直接写死了。&lt;/p>
&lt;img src="/emoji/bailan.jpg" height="150px">
&lt;h2 id="效果">效果&lt;/h2>
&lt;figure class="center" >
&lt;img src="playing.png" alt="Playing" />
&lt;figcaption class="right" >Playing&lt;/figcaption>
&lt;/figure>
&lt;figure class="center" >
&lt;img src="paused.png" alt="Paused" />
&lt;figcaption class="right" >Paused&lt;/figcaption>
&lt;/figure>
&lt;p>源代码可以在 &lt;a href="https://github.com/danzou1ge6/audlyrics/">Github&lt;/a> 找到。&lt;/p></content></item><item><title>hello_world</title><link>/posts/hello_world/</link><pubDate>Mon, 06 Feb 2023 17:27:18 +0800</pubDate><guid>/posts/hello_world/</guid><description>喂喂喂 testtesttest</description><content>&lt;p>喂喂喂
testtesttest&lt;/p></content></item><item><title/><link>/posts/kmp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/posts/kmp/</guid><description>KMP String Matching Algorithm Rational Brute-force string matching requires $O(MN)$ time, where $N$ is the length of the source string $S$, and $M$ is the length of the target string $P$.
However, utilizing the following fact, time consumption can be further reduced:
For example,
Index: 012345 S = abxabx P = abxaby &amp;lt;- Attempt 1 abx &amp;lt;- Attempt 2 When Attempt 1 failed because $S[5] \ne P[5]$, $S[:4]$ has already been matched.</description><content>&lt;h1 id="kmp-string-matching-algorithm">KMP String Matching Algorithm&lt;/h1>
&lt;h2 id="rational">Rational&lt;/h2>
&lt;p>Brute-force string matching requires $O(MN)$ time, where $N$ is the length of the &lt;strong>source string&lt;/strong> $S$, and $M$ is the length of the &lt;strong>target string&lt;/strong> $P$.&lt;/p>
&lt;p>However, utilizing the following fact, time consumption can be further reduced:&lt;/p>
&lt;p>For example,&lt;/p>
&lt;pre tabindex="0">&lt;code>Index: 012345
S = abxabx
P = abxaby &amp;lt;- Attempt 1
abx &amp;lt;- Attempt 2
&lt;/code>&lt;/pre>&lt;p>When Attempt 1 failed because $S[5] \ne P[5]$, $S[:4]$ has already been matched. Noticing that $P$ starts with &amp;ldquo;ab&amp;rdquo; while $S[3:5]$, which equals $P[3:5]$, is also &amp;ldquo;ab&amp;rdquo;, we can continue matching by aligning &amp;ldquo;x&amp;rdquo; at $P[2]$ with $S[5]$ as shown in Attempt 2.&lt;/p>
&lt;h2 id="the-next-array">The &amp;ldquo;next&amp;rdquo; Array&lt;/h2>
&lt;p>Therefore, the key to accelerating matching is by locating &lt;strong>longest identical prefix and suffix&lt;/strong>(LIPS) in $P[:j]$ for every $j$. We determine these prefixes and suffices with an &amp;ldquo;next&amp;rdquo; array $W$, defined as&lt;/p>
&lt;p>$$
W[i] = \max {k | P[:k] = P[i-k:i]
$$&lt;/p>
&lt;p>For example,&lt;/p>
&lt;pre tabindex="0">&lt;code>Index: 012345
P = abxaby
W = 010012
&lt;/code>&lt;/pre>&lt;p>To calculate $W$ from $P$, we use &lt;strong>recursion&lt;/strong>.&lt;/p>
&lt;p>Firstly, $W[0]$ is certainly $0$.&lt;/p>
&lt;p>Then, assuming that we have already obtained $W[i] = k$, and there exists $P[k] = P[i]$, we can simply set $W[i + 1]$ to $k + 1$.&lt;/p>
&lt;p>However, when $P[k] \ne P[i]$, we will have to look for a shorter LIPS.&lt;/p>
&lt;pre tabindex="0">&lt;code>Index: 0123456789ABCD
P = abyabxabyabyz
---- ----|
----- -----| &amp;lt;- i = B, W[B] = W[A] + 1
--- ---| &amp;lt;- i + 1 = C
&lt;/code>&lt;/pre>&lt;p>For example, when $i = B$, there exists LIPS &amp;ldquo;abyab&amp;rdquo;, however when $i = C$, there only exists shorter &amp;ldquo;aby&amp;rdquo;. Noticing that the shorter prefix, which is &amp;ldquo;aby&amp;rdquo;, can be splitted into two part &amp;ldquo;ab&amp;rdquo; and &amp;ldquo;y&amp;rdquo;. &amp;ldquo;ab&amp;rdquo; is actually the LIPS of &amp;ldquo;abyab&amp;rdquo;, which is again the LIPS of $P[:B]$!&lt;/p>
&lt;p>Therefore, all we have to do when $P[k] \ne P[i]$ is:&lt;/p>
&lt;ul>
&lt;li>Find the LIPS of $P[:k]$, length of which has been calculated and stored in $W[k] = l$.&lt;/li>
&lt;li>See if $P[l] = P[i]$. If so, $W[i + 1]$ would be $l + 1$. Otherwise, $W[i + 1]$ would be 0.&lt;/li>
&lt;/ul>
&lt;p>The Rust code for solving $W$ is listed below. (To simplify stuff, char codes stored in &lt;code>Vec&amp;lt;char&amp;gt;&lt;/code> is used instead of UTF-8 encoded &lt;code>String&lt;/code>)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Rust" data-lang="Rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">/// Wrapper for [`Vec&amp;lt;char&amp;gt;`]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Chars&lt;/span>(Vec&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> From&lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> Chars {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span>(s: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Self&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Self(s.chars().collect())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> From&lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>Chars&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span>(s: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Chars&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Self&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> st &lt;span style="color:#f92672">=&lt;/span> String::new();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>c &lt;span style="color:#66d9ef">in&lt;/span> s.&lt;span style="color:#ae81ff">0.&lt;/span>iter() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> st.push(c);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> st
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Pattern&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> P: &lt;span style="color:#a6e22e">Chars&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> W: Vec&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">usize&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Pattern {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span>(P: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Self&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> P &lt;span style="color:#f92672">=&lt;/span> Chars::from(P);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> W &lt;span style="color:#f92672">=&lt;/span> Vec::with_capacity(P.&lt;span style="color:#ae81ff">0.&lt;/span>len());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> W.resize(P.&lt;span style="color:#ae81ff">0.&lt;/span>len(), &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">..&lt;/span>P.&lt;span style="color:#ae81ff">0.&lt;/span>len() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> W[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> W[i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> P.&lt;span style="color:#ae81ff">0&lt;/span>[i] &lt;span style="color:#f92672">==&lt;/span> P.&lt;span style="color:#ae81ff">0&lt;/span>[k] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> l &lt;span style="color:#f92672">=&lt;/span> W[k];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> P.&lt;span style="color:#ae81ff">0&lt;/span>[l] &lt;span style="color:#f92672">==&lt;/span> P.&lt;span style="color:#ae81ff">0&lt;/span>[i] { l &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> { &lt;span style="color:#ae81ff">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Self { P, W }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Rust" data-lang="Rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> pat &lt;span style="color:#f92672">=&lt;/span> Pattern::from(&lt;span style="color:#e6db74">&amp;#34;abyabxabyabyz&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println!(&lt;span style="color:#e6db74">&amp;#34;P = {}&amp;#34;&lt;/span>, String::from(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pat.P));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println!(&lt;span style="color:#e6db74">&amp;#34;W = {:?}&amp;#34;&lt;/span>, pat.W);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>P = abyabxabyabyz
W = [0, 0, 0, 0, 1, 2, 0, 1, 2, 3, 4, 5, 3]
&lt;/code>&lt;/pre>
&lt;h2 id="matching">Matching&lt;/h2>
&lt;p>Now we have the &amp;ldquo;next&amp;rdquo; array $W$, we can do the matching.&lt;/p>
&lt;p>For example,&lt;/p>
&lt;pre tabindex="0">&lt;code>Index: 0123456
S = abyac &amp;lt;- j is used to index the char to be compared in S
- &amp;lt;- Mismatch found when i = j = 4
P = abyab &amp;lt;- i is used to index the char ... in P
W = 00001
abyab &amp;lt;- i set to W[i] = 1, and compare again
&lt;/code>&lt;/pre>&lt;p>Now mismatch occurred when $i = j = 4$, and all we have to do is to align $P$ again.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Rust" data-lang="Rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Pattern {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">match_str&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self, s: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>) -&amp;gt; Option&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">usize&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> s &lt;span style="color:#f92672">=&lt;/span> Chars::from(s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">loop&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> self.P.&lt;span style="color:#ae81ff">0.&lt;/span>len() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Some(j &lt;span style="color:#f92672">-&lt;/span> self.P.&lt;span style="color:#ae81ff">0.&lt;/span>len());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> j &lt;span style="color:#f92672">&amp;gt;=&lt;/span> s.&lt;span style="color:#ae81ff">0.&lt;/span>len() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> None;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> self.P.&lt;span style="color:#ae81ff">0&lt;/span>[i] &lt;span style="color:#f92672">==&lt;/span> s.&lt;span style="color:#ae81ff">0&lt;/span>[j] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> i &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// if P[0] mismatched, try j + 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#f92672">=&lt;/span> self.W[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Rust" data-lang="Rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> idx &lt;span style="color:#f92672">=&lt;/span> pat.match_str(&lt;span style="color:#e6db74">&amp;#34;ababyyabyabxaabyabxabyabyzab&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// -------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println!(&lt;span style="color:#e6db74">&amp;#34;Match found at {}&amp;#34;&lt;/span>, idx.unwrap());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre>&lt;code>Match found at 13
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Rust" data-lang="Rust">&lt;/code>&lt;/pre>&lt;/div></content></item></channel></rss>